# <span style="color:#8B5CF6">ì˜¨ìŒ</span> <img src="https://github.com/user-attachments/assets/42c66cd7-27d0-4246-909d-d96463410b7d" width="150" align="left" />

ì „í™” ìƒë‹´ì›ì˜ ì¸ê¶Œ ë³´í˜¸ë¥¼ ìœ„í•œ AI ìŒì„± í•„í„°ë§ ë° RAG í™œìš© ë²•ë¥  ìƒë‹´ ì±—ë´‡ ì‹œìŠ¤í…œ  
<br /><br />


## ğŸ’œ í”„ë¡œì íŠ¸ ê°œìš” ë° ì†Œê°œ

**ì˜¨ìŒ**ì€ ì „í™” ìƒë‹´ì›ë“¤ì´ ê²ªëŠ” ì–¸ì–´ì  í•™ëŒ€ ë¬¸ì œì™€ ë¯¸í¡í•œ ë³´í˜¸ ì‹œìŠ¤í…œì„ í•´ê²°í•˜ê³ ì í•©ë‹ˆë‹¤.  
**AI ê¸°ë°˜ì˜ ì‹¤ì‹œê°„ ìŒì„± í•„í„°ë§**, **í†µí™” ìš”ì•½ ë° ë¶„ì„**, **RAG í™œìš© ë²•ë¥  ìƒë‹´ ì±—ë´‡**ì„ í†µí•´  
ì „í™” ìƒë‹´ì›ì˜ ì¸ê¶Œì„ ë³´í˜¸í•˜ê³  ê±´ê°•í•œ ê·¼ë¬´ í™˜ê²½ì„ ì¡°ì„±í•˜ëŠ” ê²ƒì´ ëª©í‘œì…ë‹ˆë‹¤.

<img alt="image" src="https://github.com/user-attachments/assets/5976d733-6dbc-4ff9-a2a1-3502829b3327" /></br>


## ğŸ’¡ ê°œë°œ ë°°ê²½ ë° í•„ìš”ì„±

### 1) í”„ë¡œì íŠ¸ ì œì‘ ë™ê¸° ë° ëª©ì 
- 120ë‹¤ì‚°ì½œì¬ë‹¨ì˜ ì„¤ë¬¸ì¡°ì‚¬ ê²°ê³¼, **ê°ì •ë…¸ë™ìë³´í˜¸ë²• ì‹œí–‰ 6ë…„ì´ ì§€ë‚¬ìŒ**ì—ë„ ì—¬ì „íˆ **ì•…Â·ê°•ì„±ë¯¼ì›ì— ëŒ€í•œ ë³´í˜¸ì¡°ì¹˜ê°€ ê°•í™”ë˜ì§€ ì•Šê±°ë‚˜**, ì œë„ì ìœ¼ë¡œ ë„ì…í•˜ì˜€ì–´ë„ **ì•„ì§ ì •ì°©ë˜ì§€ ì•Šì•˜ìœ¼ë©°**, **ë³´í˜¸ì¡°ì¹˜ê°€ ì¶©ë¶„ì¹˜ ì•Šì€ ê²ƒ**ìœ¼ë¡œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.
- ë˜í•œ, ìµœê·¼ ì±—ë´‡ê³¼ AI ìƒë‹´ì›ì˜ ë„ì…ìœ¼ë¡œ **ë‹¨ìˆœ ì—…ë¬´ëŠ” AIê°€ ì²˜ë¦¬í•˜ëŠ” ë°˜ë©´**, **ìƒë‹´ì›**ë“¤ì€ **ê³µê° ë° ì„¤ë“ì˜ ê°•ë„ê°€ ë†’ê³  ë³µì¡í•œ ì—…ë¬´ë¥¼ ë‹´ë‹¹**í•˜ëŠ” **â€˜ì±…ì„ë…¸ë™** ë° **â€˜ì¶”ì‹¬ë…¸ë™**ì— ì‹œë‹¬ë¦¬ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ ê³¼ì •ì—ì„œ **ê³ ê°ì˜ ë¶ˆë§Œì´ ìƒë‹´ì›ì—ê²Œ ë” ê°•í•œ ì–¸ì–´ì  í­ë ¥ìœ¼ë¡œ í‘œì¶œë˜ëŠ” ì‚¬ë¡€ê°€ ì¦ê°€**í•˜ê³  ìˆìŠµë‹ˆë‹¤.
- ê¸°ì¡´ì˜ â€˜ê°ì •ë…¸ë™'ì´ë¼ëŠ” ìš©ì–´ëŠ” ìƒë‹´ì›ì˜ ê³ í†µì„ ê°œì¸ì˜ ë…¸ë ¥ ë¶€ì¡±ìœ¼ë¡œ ì˜¤í•´í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆê¸°ì—, **í†µì œ ë¶ˆê°€ëŠ¥í•œ ìŠ¤íŠ¸ë ˆìŠ¤ ì†ì—ì„œë„ ì¹œì ˆì„ ê°•ìš”ë°›ì•„ì•¼ í•˜ëŠ” â€˜ì •ë™ë…¸ë™â€™ì˜ ë³¸ì§ˆ**ì„ ì´í•´í•˜ê³  ì „í™” ìƒë‹´ì›ì„ ë³´í˜¸í•  ìˆ˜ ìˆëŠ” ì‹œìŠ¤í…œì„ ë§Œë“¤ê³ ì í•©ë‹ˆë‹¤.
<table>
  <tr>
    <td>
      <a href="https://www.youtube.com/watch?v=79oya3PjkFg">
        <img src="https://img.youtube.com/vi/79oya3PjkFg/0.jpg" width="600">
      </a>
    </td>
    <td>
      <img src="https://github.com/user-attachments/assets/39572b95-6e8d-480d-acee-7777ae230cbc" width="600">
    </td>
  </tr>
</table>


### 2) í”„ë¡œì íŠ¸ íŠ¹Â·ì¥ì 

ë³¸ í”„ë¡œì íŠ¸ëŠ” ì‹ ê·œ ì°½ì‘ í”„ë¡œì íŠ¸ë¡œ, ê¸°ì¡´ì˜ ì†Œê·¹ì ì¸ ì¸ê¶Œ ë³´í˜¸ ë°©ì‹ê³¼ ì°¨ë³„í™”ë˜ëŠ” ë…ì°½ì ì¸ ê¸°ëŠ¥ê³¼ ê¸°ìˆ ì  íŠ¹ì§•ì„ ê°€ì§‘ë‹ˆë‹¤.

- **AIì˜ ëŠ¥ë™ì  ìŒì„± í•„í„°ë§, ìë™ í†µí™” ì œì–´ ë° ìƒë‹´ ìš”ì•½ ì§€ì›**: STT, NLP ë“±ì˜ AIë¥¼ í™œìš©í•˜ì—¬ ë¶€ì ì ˆí•œ ë°œì–¸ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì§€í•˜ê³  ìë™ ìŒì†Œê±° ì²˜ë¦¬ ë“± ëŠ¥ë™ì ì¸ í•„í„°ë§ì„ ì ìš©
- **RAG ê¸°ë°˜ ì±—ë´‡ì„ í†µí•œ ì‹¤ì§ˆì Â·ì‹¬ì¸µì  ë²•ë¥  ìë¬¸**: 120ë‹¤ì‚°ì½œì„¼í„°ì˜ ã€Œì•…Â·ê°•ì„±ë¯¼ì› ê°ì •ë…¸ë™ìë³´í˜¸ ê°€ì´ë“œ ë¬¸ì„œã€ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•™ìŠµí•˜ì—¬, ì•…ì„±ë¯¼ì›ë¿ë§Œ ì•„ë‹ˆë¼ ê°•ì„±ë¯¼ì› ìœ í˜•ê¹Œì§€ í•™ìŠµí•˜ì—¬ ì‹¬ì¸µì ì´ê³  ì‹¤ì§ˆì ì¸ ìë¬¸ ìˆ˜ì¤€ì˜ ë‹µë³€ì„ ì œê³µ
- **ë…ì°½ì„±**:  ì‹¤ì‹œê°„ ìŒì„± í•„í„°ë§, ë²•ë¥  ìƒë‹´ ì±—ë´‡, í†µí™” ë‚´ìš© ìë™í™”ë¥¼ ìœ ê¸°ì ìœ¼ë¡œ ê²°í•©í•˜ì—¬, ë‹¨ìˆœí•œ ê¸°ìˆ  ê°œì„ ì„ ë„˜ì–´ ìƒë‹´ì›ì˜ ì •ë™ë…¸ë™ì„ ì´í•´í•˜ê³  ì¸ê¶Œ ë³´í˜¸ì™€ ì—…ë¬´ íš¨ìœ¨ì„±ì„ ë™ì‹œì— ë‹¬ì„±í•˜ëŠ” í¬ê´„ì ì¸ ì†”ë£¨ì…˜

---

## âš™ï¸ ì£¼ìš” ê¸°ëŠ¥

- ğŸ“ **ì›¹ ê¸°ë°˜ í†µí™” ìˆ˜ì‹  ë° ì‹¤ì‹œê°„ STT**  
  ê³ ê°ì´ ì „í™”ë¥¼ ê±¸ë©´ **Twilioì˜ Media Streams ê¸°ëŠ¥**ì„ í™œìš©í•˜ì—¬ ì›¹ ë¸Œë¼ìš°ì €ì—ì„œ ì§ì ‘ í†µí™”ë¥¼ ìˆ˜ì‹ í•˜ê³  ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  ìˆ˜ì‹ ëœ ìŒì„±ì€ **Google Cloudì˜ STT(Speech-to-Text) API**ë¡œ ì „ë‹¬ë˜ì–´ ì‹¤ì‹œê°„ìœ¼ë¡œ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜ë©ë‹ˆë‹¤.
  ë³€í™˜ëœ í…ìŠ¤íŠ¸ëŠ” **WebSocket í†µì‹ **ìœ¼ë¡œ ì‹¤ì‹œê°„ ë¸Œë¼ìš°ì €ì— ì „ë‹¬ë©ë‹ˆë‹¤.

- ğŸš« **í­ì–¸ ë° ê³ í•¨ ê°ì§€ í•„í„°ë§**  
  í†µí™” ì¤‘ ë°œìƒí•˜ëŠ” **í­ì–¸ê³¼ ê³ í•¨**ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ê°ì§€í•´ í•„í„°ë§í•©ë‹ˆë‹¤.
  ìŒì„±ì€ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜ëœ ë’¤ AI ëª¨ë¸ì´ **ìš•ì„¤Â·ì„±í¬ë¡±Â·í˜‘ë°• ì—¬ë¶€**ë¥¼ ë¶„ì„í•˜ë©°, ê¸°ì¤€ì„ ì´ˆê³¼í•˜ë©´ í­ì–¸ìœ¼ë¡œ íŒì •í•©ë‹ˆë‹¤.
  ê³ í•¨ì€ **ìŒì„±ì˜ ë†’ì´ì™€ ì„¸ê¸°**ë¥¼ ë¶„ì„í•˜ë©°, ë‘ íŒë‹¨ ê¸°ì¤€ì´ ëª¨ë‘ ì„ê³—ê°’ì„ ì´ˆê³¼í•  ê²½ìš° ê³ í•¨ìœ¼ë¡œ íŒì •í•˜ì—¬  
  **ë¹„í”„ìŒ ì²˜ë¦¬(ì‚ìŒ)** ë¥¼ í†µí•´ ì¦‰ì‹œ í•„í„°ë§í•©ë‹ˆë‹¤.

<table>
<tr>
  <td style="text-align:center; font-weight:bold;">
    ì„œë¹„ìŠ¤ íë¦„ë„
  </td>
  <td style="text-align:center; font-weight:bold;">
    ì„œë¹„ìŠ¤ êµ¬ì„±ë„
  </td>
</tr>
<tr>
  <td>
    <img src="https://github.com/user-attachments/assets/2f8a4fcf-2de9-4bc0-b0ec-1cc9d8dcf824" width="600">
  </td>
  <td>
    <img src="https://github.com/user-attachments/assets/2c33a9a4-763a-4a17-b81a-add7cdf02afe" width="600">
  </td>
</tr>
</table>


- ğŸ“œ **AI ìƒë‹´ë‚´ì—­ ìš”ì•½**  
  í†µí™” ì¢…ë£Œ ì‹œ AIê°€ **STT ê¸°ë°˜ í…ìŠ¤íŠ¸ì™€ í­ì–¸ ê°ì§€ ì •ë³´**ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìƒë‹´ ìš”ì•½ì„ ìƒì„±í•©ë‹ˆë‹¤.  
  í•µì‹¬ íë¦„, ê³ ê° ìš”êµ¬, ìƒë‹´ì› ë°œí™”, í­ì–¸ ìœ í˜• ë“±ì´ í¬í•¨ë˜ë©°,  
  **ê°„ë‹¨ ìš”ì•½**ê³¼ **ìƒì„¸ ìš”ì•½** ë‘ ê°€ì§€ ë²„ì „ìœ¼ë¡œ ì œê³µë˜ì–´ ìƒë‹´ì›ì˜ í•„ìš”ì— ë”°ë¼ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
  ì´ë¥¼ í†µí•´ ìƒë‹´ì›ì˜ **í›„ì²˜ë¦¬ ì—…ë¬´ ë¶€ë‹´ì„ ì¤„ì´ê³  íš¨ìœ¨ì„±ì„ í–¥ìƒ**ì‹œí‚µë‹ˆë‹¤.

<table>
<tr>
  <td style="text-align:center; font-weight:bold;">
    ì„œë¹„ìŠ¤ íë¦„ë„
  </td>
  <td style="text-align:center; font-weight:bold;">
    ì„œë¹„ìŠ¤ êµ¬ì„±ë„
  </td>
</tr>
<tr>
  <td>
    <img src="https://github.com/user-attachments/assets/b29792a6-de6f-4cbc-accb-3bdbeb95cd7f" width="600">
  </td>
  <td>
    <img src="https://github.com/user-attachments/assets/36a23a9a-a7b4-42b5-949b-27ab71275f63" width="600">
  </td>
</tr>
</table>


- âš–ï¸ **ë²•ë¥  ìƒë‹´ ì±—ë´‡**  
  **120ë‹¤ì‚°ì½œì¬ë‹¨ì˜ ì•…Â·ê°•ì„±ë¯¼ì› ê°ì •ë…¸ë™ìë³´í˜¸ ê°€ì´ë“œ ë¬¸ì„œ**ë¥¼ í•™ìŠµí•œ **RAG ê¸°ë°˜ ì±—ë´‡**ì´  
  **ê´€ë ¨ ë²•ë¥  ì¡°í•­ê³¼ ëŒ€ì‘ ë°©ì•ˆ**ì„ ëŒ€í™” í˜•ì‹ìœ¼ë¡œ ì•ˆë‚´í•˜ë©°,  
  **ë²¡í„°DB ê²€ìƒ‰(Pinecone)** ê³¼ **AI ëª¨ë¸(OpenAI GPT)** ì„ ê²°í•©í•´ **ì‹ ë¢°ë„ ë†’ì€ ìë¬¸**ì„ ì œê³µí•©ë‹ˆë‹¤.

<table>
<tr>
  <td style="text-align:center; font-weight:bold;">
    ì„œë¹„ìŠ¤ íë¦„ë„
  </td>
  <td style="text-align:center; font-weight:bold;">
    ì„œë¹„ìŠ¤ êµ¬ì„±ë„
  </td>
</tr>
<tr>
  <td>
    <img src="https://github.com/user-attachments/assets/8ee0a64b-b00c-464f-b496-904c16602c09" width="600">
  </td>
  <td>
    <img src="https://github.com/user-attachments/assets/03dccbb0-d590-4d12-a4df-fa0a48da90b8" width="600">
  </td>
</tr>
</table>

<br />

---

## âœ¨ ê¸°ëŒ€íš¨ê³¼ ë° í™œìš©ë¶„ì•¼

**ì‹¤ì‹œê°„ í­ì–¸ ì°¨ë‹¨**ìœ¼ë¡œ ìƒë‹´ì›ì˜ ì‹¬ë¦¬ì  ì•ˆì „ë§ì„ ë§ˆë ¨í•˜ê³ ,  
**ìë™ ìš”ì•½ ê¸°ëŠ¥**ìœ¼ë¡œ ìƒë‹´ í›„ì²˜ë¦¬ ë¶€ë‹´ì„ ê²½ê°í•©ë‹ˆë‹¤.  
ë˜í•œ **ë²•ë¥  ìƒë‹´ ì±—ë´‡**ì„ í†µí•´ êµ¬ì²´ì ì¸ ëŒ€ì‘ ë°©ì•ˆì„ ì œê³µí•©ë‹ˆë‹¤.


ì´ ì‹œìŠ¤í…œì€ **ìƒë‹´ì›ë¿ë§Œ ì•„ë‹ˆë¼ êµì‚¬Â·ê³µì§ì ë“± ê°ì •ë…¸ë™ ì§êµ°**ìœ¼ë¡œ í™•ì¥ ê°€ëŠ¥í•˜ë©°,  
**êµ­ê°€ ì°¨ì›ì˜ ì†Œë²„ë¦° AI ì „ëµ**ê³¼ë„ ë¶€í•©í•´ **ì‚¬íšŒì  íŒŒê¸‰ íš¨ê³¼**ë¥¼ ì°½ì¶œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
<table>
  <tr>
    <td>
      <img src="https://github.com/user-attachments/assets/42798a83-9075-4db3-921f-ae37f32ae587" width="600">
    </td>
    <td>
      <img src="https://github.com/user-attachments/assets/1e75d20a-dd96-4ec2-9c09-bfb888f665a4" width="600">
    </td>
  </tr>
</table>

<table>
  <tr>
    <td>
      <img src="https://github.com/user-attachments/assets/8a10ced0-1fc3-4f10-9e8a-fff1c43409ee" width="600">
    </td>
    <td>
      <img src="https://github.com/user-attachments/assets/b94a1dfa-4a6c-444d-9adf-c75d2dec2b42" width="600">
    </td>
  </tr>
</table>

---

## <img src="https://github.com/user-attachments/assets/d279eded-37a1-4816-a04d-e5fee577b069" alt="YouTube" width="20"/> ì‘í’ˆ ì†Œê°œ ì˜ìƒ

[![ì˜¨ìŒ ì‹œì—°ì˜ìƒ](https://github.com/user-attachments/assets/039e13b2-02fb-4964-a10f-f846df709dd7)](https://youtu.be/4NJF_fCZPIM?si=C-7njz59XTcrmEes)

---

## ğŸ‘¥ íŒ€ì› ì†Œê°œ

| <img src="https://avatars.githubusercontent.com/u/145523888?v=4" width="120px;" alt=""/> | <img src="https://avatars.githubusercontent.com/u/144589197?v=4" width="120px;" alt=""/> | <img src="https://avatars.githubusercontent.com/u/144600629?v=4" width="120px;" alt=""/> | <img src="https://avatars.githubusercontent.com/u/90364609?v=4" width="120px;" alt=""/> | <img src="https://avatars.githubusercontent.com/u/102063992?v=4" width="120px;" alt=""/> |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| [**ì´ì†¡ë¯¸**](https://github.com/soooong7) | [**ì „íš¨ë¯¼**](https://github.com/hyom1n) | [**ì¡°ì˜ˆì˜**](https://github.com/sylvia1213) | [**ì˜¤ì„¸ì€**](https://github.com/ose0221) | [**ìµœí˜„ì§€**](https://github.com/hyeonjichoi21) |
| â€¢ íŒ€ì¥ <br> â€¢ ë°±ì—”ë“œ Â· AI(í­ì–¸ í•„í„°ë§, ìš”ì•½)<br>â€¢ CI/CD(AI) | â€¢ í”„ë¡ íŠ¸ì—”ë“œ | â€¢ í”„ë¡ íŠ¸ì—”ë“œ | â€¢ ë°±ì—”ë“œ Â· AI(ìš”ì•½) | â€¢ ë°±ì—”ë“œ Â· AI(ì±—ë´‡)<br>â€¢ ì„œë²„ êµ¬ì¶• <br>â€¢ CI/CD(ë°±ì—”ë“œ)|


---

## ğŸ›  ì‚¬ìš© ê¸°ìˆ  ìŠ¤íƒ

| êµ¬ë¶„               | ì‚¬ìš© ê¸°ìˆ  ë° ë„êµ¬                                                    |
|:------------------|:-----------------------------------------------------------------|
| **Backend**       | SpringBoot, MySQL, MongoDB, Elasticsearch, FastAPI, WebSocket / SSE |
| **Frontend**      | React, WebSocket / SSE                                            |
| **AI & Data**     | ìš•ì„¤/ì„±í¬ë¡±/í˜‘ë°• ê°ì§€ - KoBERT,<br/>STT - Google Cloud Speech-to-Text,<br/>ìƒë‹´ìš”ì•½ - OpenAI gpt-4o, Gemini 2.5 flash,<br/>RAG ê¸°ë°˜ ì±—ë´‡ - OpenAI gpt3-small, Pinecone |
| **Infra & DevOps**| AWS EC2, RDS, Route53, Nginx, Docker, Docker Compose, GitHub Actions (CI/CD), Vercel |
| **Communication tools** | Github, Notion, Discord, Google sheet                              |
| **WebRTC Communication**        | Twilio                                                             |

---

## ğŸ–¥ ì‹œìŠ¤í…œ êµ¬ì„±ë„

### ğŸ”¹ **ì•„í‚¤í…ì²˜ êµ¬ì¡°**
<img src="https://github.com/user-attachments/assets/f114a2c5-f2b3-439c-87ea-32802157fe92" style="width:100%; height:auto;" />

### ğŸ”¹ **ERD**
<img src="https://github.com/user-attachments/assets/c2abbc6b-91ff-4df5-b6f5-2b66a3fecf7a" style="width:100%; height:auto;" />

## ğŸ–¥ í•µì‹¬ ì†ŒìŠ¤ì½”ë“œ

<details>
  <summary><h3>WebSocketProviderë¥¼ í†µí•œ ì „ì—­ ìƒíƒœ ê´€ë¦¬</h3></summary>

```tsx
// WebsocketContext.js 
useEffect(() => {
  ws.onmessage = (event) => {
    switch (event.type) {
      case "stt":
        // [STT] ìˆ˜ì‹ ë¨
        console.log("ğŸŸª [STT] ìˆ˜ì‹ ë¨", event.data.payload);
        const { track, script, isFinal, isAbuse, abuseType } = event.data.payload;
        setCallLogs((prevLogs) => {
          const lastLogIndex = prevLogs.length - 1;
          const newLog = { track, script, isFinal, isAbuse, abuseType };

          // ë§ˆì§€ë§‰ ë¡œê·¸ê°€ í˜„ì¬ íŠ¸ë™ì˜ ì¤‘ê°„ ê²°ê³¼ì¼ ê²½ìš° ë®ì–´ì“°ê¸°
          if (
            lastLogIndex >= 0 &&
            prevLogs[lastLogIndex].track === track &&
            !prevLogs[lastLogIndex].isFinal
          ) {
            // ì¤‘ê°„ ê²°ê³¼ ì—…ë°ì´íŠ¸ (React ë¶ˆë³€ì„± ìœ ì§€)
            const updatedLogs = [...prevLogs];
            updatedLogs[lastLogIndex] = newLog;
            return updatedLogs;
          } else {
            // ìƒˆë¡œìš´ ë¡œê·¸ë¡œ ì¶”ê°€
            return [...prevLogs, newLog];
          }
        });
        break;
      // ...
    }
  };
}, []);

export const WebSocketProvider = ({ children }) => {
  // Twilio + WS ì†Œì¼“ ì¢…ë£Œ
  // í†µí™” ë° WebSocket ëª¨ë‘ ì¢…ë£Œ
  const endCallAndDisconnect = () => {
    try {
      const conn = twilioConnectionRef.current;
      if (conn?.disconnect && conn.status?.() !== "closed") {
        conn.disconnect(); // 1: ì¼ë°˜ ì¢…ë£Œ
      } else if (twilioDeviceRef.current?.disconnectAll) {
        twilioDeviceRef.current.disconnectAll(); // 2: ëª¨ë“  ì—°ê²° ì¢…ë£Œ
      } else {
        console.warn("No Twilio refs, fallback to WS close");
        endConnectWebSocket();
      }
    } catch (e) {
      console.error("Twilio disconnect error:", e);
      twilioDeviceRef.current?.disconnectAll?.();
    }
    setIsCallEnded(true);

    // ì•ˆì „ë§: Twilio ì´ë²¤íŠ¸ê°€ ì•ˆ ì˜¤ë©´ ì¼ì • ì‹œê°„ ë’¤ ê°•ì œ ì¢…ë£Œ
    setTimeout(() => {
      if (wsRef.current?.readyState !== WebSocket.OPEN) {
        console.log("ğŸ’£ Fallback closing ws");
        wsRef.current.close();
      }
    }, 1500);
  };
};
```
</details> 


<details> <summary><h3>SSE ê¸°ë°˜ ì±—ë´‡ ì‘ë‹µ ì²˜ë¦¬ êµ¬ì¡°</h3></summary>
  
```js
// Chatbot.js
// --- ê³µìš© SSE ì§„ì… ---
const openSseAndStream = ({ url, sessionId }) => {
  const which = activeTab === 'ì¼ë°˜' ? 'general' : 'consult';
  const eventSource = new EventSource(url);
  let buffer = '';

  const replaceLoadingWith = (text) => {
    setCurrentChatMap((prev) => {
      const msgs = prev[sessionId] || [];
      const idx = msgs.findIndex(m => m.loading);
      if (idx !== -1) {
        const updated = { ...msgs[idx], fromUser: false, text };
        const updatedMsgs = [...msgs];
        updatedMsgs[idx] = updated;
        return { ...prev, [sessionId]: updatedMsgs };
      }
      return prev;
    });
  };

  // ì œëª© ì´ë²¤íŠ¸ ì¦‰ì‹œ ë°˜ì˜
  eventSource.addEventListener('title', (ev) => {
    try {
      const payload = JSON.parse(ev.data);
      const sid = payload?.sessionId ?? sessionId;
      const title = payload?.title;
      applySessionTitle(which, sid, title);
    } catch (e) {}
  });

  // ë©”ì‹œì§€ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬
  eventSource.addEventListener('message', (event) => {
    const chunk = event.data;

    if (chunk === '[END]') {
      buffer = buffer.trim();
      try {
        const jsonStart = buffer.indexOf('{');
        const jsonEnd = buffer.lastIndexOf('}') + 1;
        const parsed = JSON.parse(buffer.substring(jsonStart, jsonEnd).trim());
        if (parsed.answer) {
          replaceLoadingWith(formatBotMessage(parsed.answer, parsed.sourcePages));
        } else {
          replaceLoadingWith('â—ï¸ì‘ë‹µ í˜•ì‹ ì—†ìŒ');
        }
      } catch (e) {
        replaceLoadingWith('â—ï¸ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨');
      }
      eventSource.close();
      return;
    }

    if (chunk.startsWith('[JSON]')) {
      buffer = chunk.replace('[JSON]', '').trim();
    }
  });

  eventSource.onerror = () => {
    replaceLoadingWith('â—ï¸ì—°ê²° ì‹¤íŒ¨');
    eventSource.close();
  };
};
```

</details> 

<details>
  <summary><h3>WebRTC ê¸°ë°˜ ì‹¤ì‹œê°„ í†µí™” êµ¬í˜„</h3></summary>

```java
// TwilioVoiceTokenController.java
@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/token")
@Tag(
        name = "TwilioVoiceToken",
        description = "Twilio ìŒì„± í†µí™”ë¥¼ ìœ„í•œ ì•¡ì„¸ìŠ¤ í† í° ë°œê¸‰ API. ë¸Œë¼ìš°ì € í´ë¼ì´ì–¸íŠ¸ê°€ Twilio Voice SDKë¥¼ ì‚¬ìš©í•´ ì „í™”ë¥¼ ìˆ˜Â·ë°œì‹ í•  ìˆ˜ ìˆë„ë¡ í† í°ì„ ë°œê¸‰í•©ë‹ˆë‹¤."
)
public class TwilioVoiceTokenController {
    @Value("${twilio.account.sid}")
    private String TWILIO_ACCOUNT_SID;

    @Value("${twilio.api.key}")
    private String TWILIO_API_KEY;

    @Value("${twilio.api.secret}")
    private String TWILIO_API_SECRET;

    @GetMapping
    public ApiResponse<TwilioTokenResponseDTO> getToken(
        @UserId Long userId
    ){
        String fixedIdentity = "browserUser"; // ê³ ì • ID - ë‹¨ì¼ ì‚¬ìš©ìë¡œ êµ¬í˜„, ì¶”í›„ ìƒë‹´ì‚¬ ë¶„ë°° ì‹œì— ë‹¤ì¤‘ ì‚¬ìš©ìë¡œ í™•ì¥ ê°€ëŠ¥
        VoiceGrant grant = new VoiceGrant();
        grant.setIncomingAllow(true);

        AccessToken token = new AccessToken.Builder(
                TWILIO_ACCOUNT_SID,
                TWILIO_API_KEY,
                TWILIO_API_SECRET
        )
                .identity(fixedIdentity)
                .grant(grant)
                .ttl(3600)
                .build();

        log.info("access token: {}", token.toString());
        log.info("userId : {}", userId);

        TwilioTokenResponseDTO twilioTokenResponseDTO = TwilioTokenResponseDTO.of(token.toJwt(),  userId);
        return ApiResponse.onSuccess(twilioTokenResponseDTO);
    }
}

// TwilioWebhookController.java
@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/twilio")
@Tag(
        name = "TwilioWebhook",
        description = "Twilio ìŒì„± í†µí™” Webhook API. ì¸ë°”ìš´ë“œ ì½œ ìˆ˜ì‹  ì‹œ ë¸Œë¼ìš°ì € í´ë¼ì´ì–¸íŠ¸ì™€ WebSocketì„ ì—°ê²°í•˜ê³  í†µí™” íë¦„(TwiML)ì„ ì œì–´í•©ë‹ˆë‹¤."
)
public class TwilioWebhookController {
    private static final String BROWSER_CLIENT_ID = "browserUser";
    private static final String WS_URL ="wss://callprotect.site/ws/audio";

    @PostMapping(value = "/voice", consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE, produces = MediaType.APPLICATION_XML_VALUE)
    public String onIncomingCall(@RequestParam Map<String, String> params) {
        log.info("params: {}", params);
        log.info("â˜† Inbound Call - From: {}", params.get("From"));
        log.info("â˜† Inbound Call - CallSid: {}", params.get("CallSid"));
        String callerNumber = params.get("From");
        String inboundCallSid = params.get("CallSid");

        Client clientVerb = new Client.Builder(BROWSER_CLIENT_ID) // ë¸Œë¼ìš°ì € Client ID - TwilioVoiceTokenControllerì˜ fixedIdentityì™€ ì¼ì¹˜í•´ì•¼ í•¨
            .parameter(new Parameter.Builder()
                .name("initialCallSid")
                .value(inboundCallSid)
                .build())
            .build();

        VoiceResponse response = new VoiceResponse.Builder()
                .say(new Say.Builder("ì‚°ì—…ì•ˆì „ë³´ê±´ë²•ì— ë”°ë¼ ê³ ê°ì‘ëŒ€ ê·¼ë¡œì ë³´í˜¸ ì¡°ì¹˜ê°€ ì‹œí–‰ë˜ê³  ìˆìŠµë‹ˆë‹¤." +
                        "ì„¸ ë²ˆ ì´ìƒ í­ì–¸ì´ ê°ì§€ë˜ë©´ ì—ì´ì•„ì´ì— ì˜í•´ í†µí™”ê°€ ìë™ ì¢…ë£Œë©ë‹ˆë‹¤.")
                    .voice(Say.Voice.ALICE)
                    .language(Say.Language.KO_KR)
                    .build())
                .start(new Start.Builder()
                        .stream(new Stream.Builder()
                                .url(WS_URL)
                                .track(Stream.Track.BOTH_TRACKS)
                                .parameter(new com.twilio.twiml.voice.Parameter.Builder()
                                    .name("primaryCallSid")
                                    .value(inboundCallSid)
                                        .build())
                                .parameter(new com.twilio.twiml.voice.Parameter.Builder()
                                        .name("callerNumber")
                                        .value(callerNumber)
                                        .build())
                                .build())
                        .build())
                .dial(new Dial.Builder()
                        .timeout(30) // 30ì´ˆ ì•ˆì— ì‘ë‹µ ì—†ìœ¼ë©´ í†µí™” ë¶ˆê°€ ì•ˆë‚´ ë©˜íŠ¸
                        .client(clientVerb)
                        .build())
                .say(new Say.Builder("ì§€ê¸ˆì€ í†µí™”ê°€ ë¶ˆê°€ëŠ¥í•œ ì‹œê°„ì…ë‹ˆë‹¤. ë‚˜ì¤‘ì— ë‹¤ì‹œ ê±¸ì–´ì£¼ì„¸ìš”.") // ì•ˆë‚´ ë©˜íŠ¸ ìˆ˜ì • ì˜ˆì •
                        .voice(Say.Voice.ALICE)
                        .language(Say.Language.KO_KR)
                        .build())

                .build();

        return response.toXml(); // TwiML ë°˜í™˜
    }
}
```
</details> 


<details>
  <summary><h3>ìƒë‹´ ìŒì„± STT</h3></summary>

```java
// ShoutingDetector.java
private ResponseObserver<StreamingRecognizeResponse> createResponseObserver(String sessionId){
		return new ResponseObserver<>() {
			public void onStart(StreamController controller) {
				log.info("ğŸ¤ STT ì‹œì‘ë¨: {} [{}]", sessionId, track);
			}

			public void onResponse(StreamingRecognizeResponse response) {
				for (StreamingRecognitionResult result : response.getResultsList()) {
					if (result.getAlternativesCount() > 0) {
						String transcript = result.getAlternatives(0).getTranscript();
						boolean isFinal = result.getIsFinal();

						log.info("ğŸ’¬ [{}][{}] {}", isFinal ? "ìµœì¢…" : "ì¤‘ê°„",
							track == CallTrack.INBOUND ? "ê³ ê°" : "ìƒë‹´ì›",
							transcript);

						try {
							if (isFinal) { // ìµœì¢… ê²°ê³¼
								String trimmedTranscript = transcript.trim();

								// ì¤‘ë³µ ë°©ì§€ - ì´ì „ ì €ì¥ê°’ê³¼ ë™ì¼í•œ ê²½ìš° ì €ì¥ ìƒëµ (INBOUNDë§Œ ì ìš©)
								if(isDuplicate(trimmedTranscript)) {
									log.debug("[ì¤‘ë³µ ì œê±°] ë™ì¼í•œ ìµœì¢… í…ìŠ¤íŠ¸ëŠ” ë¬´ì‹œë¨: {}", trimmedTranscript);
									continue;
								}

								boolean isAbuse = NOT_ABUSIVE;
								String abuseType = ABUSIVE_TYPE_NORMAL;

								// INBOUND íŠ¸ë™ë§Œ FastAPIë¥¼ í†µí•œ ìš•ì„¤ ë¶„ì„
								if(track == CallTrack.INBOUND) {
									var analysis = fastClient.sendTextToFastAPI(trimmedTranscript);
									isAbuse = analysis.isAbuse();
									abuseType = analysis.getType();
									if (isAbuse) {
										log.info("[{}] INBOUND ìš•ì„¤ ê°ì§€ ê²°ê³¼ â†’ isAbuse: {}, type: {}", CallTrack.INBOUND, isAbuse, abuseType);
									}
								} else { // // OUTBOUND íŠ¸ë™ì€ ìš•ì„¤ ë¶„ì„ ê±´ë„ˆëœ€
									log.info("[{}] ìƒë‹´ì› ë°œí™”ëŠ” ìš•ì„¤ ë¶„ì„ì„ ê±´ë„ˆëœ€", track);

								}

								// sttLog ìµœì¢… ì €ì¥
								CallSttLog savedLog = callSttLogService.saveTranscriptLog(
									callSessionId,
									track,
									trimmedTranscript,
									true,
									isAbuse,
									abuseType
								);
								log.info("MongoDBì— CallSttLog ì €ì¥ ì™„ë£Œ: callSessionId={}, track={}, script={}", callSessionId, track, trimmedTranscript);



								// INBOUND (ê³ ê°) ìŠ¤í¬ë¦½íŠ¸ ëˆ„ì  ë° ìš•ì„¤ ê°ì§€ í›„ ì²˜ë¦¬
								if (track == CallTrack.INBOUND) {
									// transcriptBuilder ì¤‘ë³µ ëˆ„ì  ë°©ì§€
									if (!trimmedTranscript.equals(lastSavedFinalTranscript)) {
										transcriptBuilder.append(trimmedTranscript).append(" ");
										lastSavedFinalTranscript = trimmedTranscript;
									}

									// ìš•ì„¤ ê°ì§€ ì‹œ total abuse cnt ì—…ë°ì´íŠ¸
									if (isAbuse) {
										log.info("STT ê²°ê³¼ ìš•ì„¤ ê°ì§€ - (isAbuse={}) / CallSession total_abuse_cnt ì—…ë°ì´íŠ¸ ì‹œë„ - CallSessionId={}", isAbuse, callSessionId);
										callSessionService.incrementTotalAbuseCnt(callSessionId);
										log.info("ğŸ€ ê³ ê° ë°œí™” í•„í„°ë§ë¨");
										callLogService.updateAbuse(callSessionId, track);
										sendBeepIfAllowed(BEEP_DURATION_MS);
									}
								} else { // OUTBOUND (ìƒë‹´ì›) ìŠ¤í¬ë¦½íŠ¸ ëˆ„ì 
									// ì¤‘ë³µ ëˆ„ì  ë°©ì§€ ì—†ì´ ë¬´ì¡°ê±´ ì¶”ê°€
									transcriptBuilder.append(trimmedTranscript).append(" ");
									lastSavedFinalTranscript = trimmedTranscript;
								}

								// í´ë¼ì´ì–¸íŠ¸ì— ìµœì¢… STT ê²°ê³¼ ì „ì†¡
								CallSttLogResponseDTO finalResponse = new CallSttLogResponseDTO(DATA_TYPE_STT, savedLog);

								if (userId != null) {
									sttWebSocketHandler.sendSttToClient(userId, finalResponse);
								}

								partialFinalTranscript = null; // ìµœì¢… ì²˜ë¦¬ í›„ ì¤‘ê°„ í…ìŠ¤íŠ¸ ì´ˆê¸°í™”

							} else { // ì¤‘ê°„ ê²°ê³¼ëŠ” DB ì €ì¥ ì—†ì´ í´ë¼ì´ì–¸íŠ¸ ë·°ì—ë§Œ ë³´ì—¬ì¤Œ
								CallSttLog interimLog = CallSttLog.builder()
									.callSessionId(callSessionId)
									.track(track)
									.script(transcript)
									.isFinal(false)
									.isAbuse(false)
									.abuseType(ABUSIVE_TYPE_NORMAL)
									.abuseCnt(0)
									.build();

								// í´ë¼ì´ì–¸íŠ¸ì— ì¤‘ê°„ STT ê²°ê³¼ ì „ì†¡
								CallSttLogResponseDTO interimResponse = new CallSttLogResponseDTO(DATA_TYPE_STT, interimLog);

								if (userId != null) {
									sttWebSocketHandler.sendSttToClient(userId, interimResponse);
								}

								partialFinalTranscript = transcript;
							}

						} catch (Exception e) {
							log.error("âŒ FastAPI ì „ì†¡ ì˜¤ë¥˜", e);
						}
					}
				}
			}

			public void onError(Throwable t) {
				log.error("[{}] STT ì˜¤ë¥˜", track, t);
			}

			public void onComplete() {
				log.info("[{}] STT ì™„ë£Œ", track);
			}
		};
	}
```
</details> 

<details>
  <summary><h3>ê³ í•¨ ê°ì§€ ë° í•„í„°ë§</h3></summary>

```java
// SttContext.java
private void calculateBaselineAndSetThreshold() {
		if (basePitches.isEmpty() || baseVolumes.isEmpty()) {
			log.warn("ë² ì´ìŠ¤ë¼ì¸ ìˆ˜ì§‘ì¹˜ ë¶€ì¡± â†’ default ì„ê³„ê°’ ìœ ì§€");
			setThresholdsFrom(provisionalBasePitchHz, provisionalBaseVolumeDb,false);
			return;
		}

		// ì •ë ¬
		Collections.sort(basePitches);
		Collections.sort(baseVolumes);

		// ì¤‘ì•™ê°’ ì¶”ì¶œ
		double medianBasePitch = basePitches.get(basePitches.size() / 2);
		double medianBaseVolume = baseVolumes.get(baseVolumes.size() / 2);

		setThresholdsFrom(medianBasePitch, medianBaseVolume,true);


		log.info("âœ… ê¸°ì¤€ í”¼ì¹˜ ì„¤ì • ì™„ë£Œ: {}Hz, ê³ í•¨ ì„ê³„ê°’: {}Hz", medianBasePitch, shoutingPitchThreshold);
		log.info("âœ… ê¸°ì¤€ ë³¼ë¥¨ ì„¤ì • ì™„ë£Œ: {}dB, ê³ í•¨ ì„ê³„ê°’: {}dB", medianBaseVolume, shoutingVolumeThreshold);
	}
	
private void setThresholdsFrom(double basePitch, double baseVolume, boolean markBaselineSet) {
	this.isHighPitchUser = (basePitch > PITCH_BOUNDARY);
	double pitchIncreaseFactor = this.isHighPitchUser ? PITCH_INCREASE_FACTOR_HIGH : PITCH_INCREASE_FACTOR_LOW;

	this.shoutingPitchThreshold  = basePitch  * pitchIncreaseFactor;
	this.shoutingVolumeThreshold = baseVolume + DB_BOUNDARY;

	if (markBaselineSet) {
		isBaselineSet.set(true);
		log.info("âœ… ê°œë³„ ê¸°ì¤€ ì„ê³„ê°’ ì ìš©: basePitch={}Hz, baseVol={}dB â†’ thresPitch={}Hz, thresVol={}dB",
			basePitch, baseVolume, shoutingPitchThreshold, shoutingVolumeThreshold);
	} else {
		log.info("â³ ì„ì‹œ ì„ê³„ê°’ ì ìš©(default: basePitch={}Hz, baseVol={}dB â†’ thresPitch={}Hz, thresVol={}dB",
			basePitch, baseVolume, shoutingPitchThreshold, shoutingVolumeThreshold);
	}
}
```
</details> 

<details>
  <summary><h3>í­ì–¸ ê°ì§€ ë° í•„í„°ë§</h3></summary>

```python
# detect.py
# ì„¤ì •
LABEL_NAMES = ["ìš•ì„¤", "ì„±í¬ë¡±", "í˜‘ë°•", "ì •ìƒ"]
MODEL_PATH = "./model/kobert_v12"
THRESHOLD = 0.9
DELTA_THRESHOLD = 0.2
NORMAL_CLASS_INDEX = 3

# ë‹¨ì–´ ì‚¬ì „ ë¡œë”©
with open("data/badwords.json", encoding="utf-8") as f:
    BADWORDS = set(json.load(f)["badwords"])

with open("data/force_block.json", encoding="utf-8") as f:
    FORCE_BLOCK = set(json.load(f)["force_block"])

# ì „ì²˜ë¦¬
def normalize(text: str) -> str:
    return re.sub(r"[^ê°€-í£a-zA-Z0-9\s]", "", text).lower().strip()

def contains_badword(norm_text: str):
    return [word for word in BADWORDS if word in norm_text]

# KoBERT ëª¨ë¸ ì •ì˜
class KoBERTClassifier(BertPreTrainedModel):
    def __init__(self, config):
        super().__init__(config)
        self.bert = BertModel(config)
        self.dropout = nn.Dropout(0.2)
        self.classifier = nn.Linear(config.hidden_size, config.num_labels)

    def forward(self, input_ids=None, attention_mask=None, token_type_ids=None):
        outputs = self.bert(input_ids=input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids)
        pooled_output = self.dropout(outputs.pooler_output)
        logits = self.classifier(pooled_output)
        return logits

# ëª¨ë¸ ë° í† í¬ë‚˜ì´ì € ë¡œë”©
tokenizer = AutoTokenizer.from_pretrained("monologg/kobert", trust_remote_code=True)
config = AutoConfig.from_pretrained(MODEL_PATH)
model = KoBERTClassifier.from_pretrained(MODEL_PATH, config=config)
model.eval()

# ì˜ˆì¸¡ í•¨ìˆ˜
def predict(text: str):
    inputs = tokenizer(text, return_tensors="pt", padding="max_length", truncation=True, max_length=64)
    with torch.no_grad():
        logits = model(**inputs)
        probs = F.softmax(logits, dim=1)[0].tolist()
    pred_idx = int(torch.argmax(logits, dim=1).item())
    pred_label = LABEL_NAMES[pred_idx]
    return probs, pred_label, pred_idx

# ìµœì¢… íŒë³„ í•¨ìˆ˜
def is_abuse(text: str):
    norm = normalize(text)
    detected = contains_badword(norm)

    # ê°•ì œ ì°¨ë‹¨ ë‹¨ì–´ ìš°ì„  ê°ì§€
    if any(word in FORCE_BLOCK for word in detected):
        return True, detected, "ìš•ì„¤"

    # ëª¨ë¸ ì˜ˆì¸¡
    probs, pred_label, pred_idx = predict(text)
    max_prob = max(probs[:NORMAL_CLASS_INDEX])
    normal_prob = probs[NORMAL_CLASS_INDEX]
    delta = max_prob - normal_prob

    is_abusive = (
        pred_idx != NORMAL_CLASS_INDEX and
        max_prob > THRESHOLD and
        delta > DELTA_THRESHOLD and
        normal_prob < 0.3
    )

    # ì˜¤íƒ ë³´ì • ì¡°ê±´
    if is_abusive and not detected:
        if max_prob < 0.97 or normal_prob > 0.2:
            is_abusive = False

    # ì •ìƒ íŒë‹¨
    if not is_abusive and not detected:
        return False, [], "ì •ìƒ"

    return is_abusive, detected, pred_label

```
</details> 


<details>
  <summary><h3>AI ìƒë‹´ìš”ì•½</h3></summary>

```java
// CallSessionServiceImpl.java
@Override
    public String generateSummaryByOpenAi(Long callSessionId, Long userId) {
        CallSession session = findCallSessionByIdAndUserId(callSessionId, userId);

        if (session.getSummarySimple() != null && !session.getSummarySimple().isBlank()) {
            log.info("âœ… ê¸°ì¡´ ìš”ì•½ ë°˜í™˜ - CallSession ID: {}", callSessionId);
            return session.getSummarySimple();
        }

        try {
            List<CallSttLog> sttLogs = callSttLogService.getAllBySessionId(callSessionId);

            if (sttLogs.isEmpty()) {
                log.warn("âš ï¸ STT ë¡œê·¸ ì—†ìŒ - CallSession ID: {}", callSessionId);
                throw new CallSessionSummaryGenerationException(ErrorStatus.CANT_SUMMARY_CALL_STT_LOG);
            }

            boolean hasMeaningfulScript = sttLogs.stream()
                    .anyMatch(log -> log.getScript() != null && !log.getScript().trim().isEmpty());

            if (!hasMeaningfulScript) {
                log.warn("âš ï¸ ìœ íš¨í•œ ëŒ€í™” ë‚´ìš© ì—†ìŒ - CallSession ID: {}", callSessionId);
                throw new CallSessionSummaryGenerationException(ErrorStatus.CALL_STT_LOG_NO_MEANINGFUL_CONTENT);
            }

            String fullConversation = sttLogs.stream()
                    .filter(log -> {
                        String script = log.getScript();
                        return script != null && !script.trim().isEmpty();
                    })
                    .map(log -> {
                        String script = log.getScript().trim();
                        String speaker = (log.getTrack() == CallTrack.INBOUND) ? "ê³ ê°" : "ìƒë‹´ì›";
                        return String.format("[%s]: %s", speaker, script);
                    })
                    .collect(Collectors.joining("\n"));

            String summary = openAiSummaryService.summarize(fullConversation);
            log.info("âœ… ìš”ì•½ ìƒì„± ì™„ë£Œ - CallSession ID: {}", callSessionId);

            session.updateSummarySimple(summary);
            callSessionRepository.save(session);

            return summary;

        } catch (Exception e) {
            log.error("âŒ ìš”ì•½ ìƒì„± ì¤‘ ì˜¤ë¥˜ - CallSession ID: {}, ë©”ì‹œì§€: {}", callSessionId, e.getMessage(), e);
            throw new CallSessionSummaryGenerationException(ErrorStatus.SUMMARY_AI_OPENAI_API_ERROR);
        }
    }

    @Override
    public CallSessionResponseDTO.CallSessionSummaryResponseDTO createCallSessionSummaryByOpenAi(Long callSessionId, Long userId) {
        String summaryText = generateSummaryByOpenAi(callSessionId, userId);

        return CallSessionResponseDTO.CallSessionSummaryResponseDTO.builder()
                .callSessionId(callSessionId)
                .summaryText(summaryText)
                .build();
    }

    @Override
    @Transactional
    public String generateSummaryByGemini(Long callSessionId, Long userId) {
        CallSession session = findCallSessionByIdAndUserId(callSessionId, userId);

        // ì¤‘ë³µ ìƒì„± ë°©ì§€
        if (session.getSummaryDetailed() != null && !session.getSummaryDetailed().isBlank()) {
            log.info("CallSession (ID: {})ì— ì´ë¯¸ ìš”ì•½ ì™„ë£Œ. Gemini api í˜¸ì¶œ ì—†ì´ ê¸°ì¡´ ìš”ì•½ ë‚´ìš© ë°˜í™˜", callSessionId);
            return session.getSummaryDetailed();
        }

        String summaryText;

        try {
            // ì „ì²´ ìŠ¤í¬ë¦½íŠ¸ ì¡°íšŒ
            List<CallSttLog> scriptLogs = callSttLogService.getAllBySessionId(callSessionId);

            if (scriptLogs.isEmpty()) {
                log.warn("CallSession (ID: {})ì— ìµœì¢… STT ë¡œê·¸ê°€ ì—†ì–´ ìš”ì•½ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", callSessionId);
                throw new CallSessionSummaryGenerationException(ErrorStatus.CANT_SUMMARY_CALL_STT_LOG);
            }

            // í•˜ë‚˜ì˜ ì „ì²´ ìŠ¤í¬ë¦½íŠ¸ë¡œ ê°€ê³µ
            String fullConversation = scriptLogs.stream()
                .map(log -> {
                    String speaker = log.getTrack().toString().equals("INBOUND") ? "ê³ ê°" : "ìƒë‹´ì›";
                    return String.format("[%s]: %s", speaker, log.getScript());
                })
                .collect(Collectors.joining("\n"));

            boolean hasMeaningfulScript = scriptLogs.stream()
                .anyMatch(log -> log.getScript() != null && !log.getScript().trim().isEmpty());

            if (!hasMeaningfulScript) {
                log.warn("CallSession (ID: {})ì— ì˜ë¯¸ ìˆëŠ” ëŒ€í™” ë‚´ìš©ì´ ì—†ì–´ ìš”ì•½ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", callSessionId);
                throw new CallSessionSummaryGenerationException(ErrorStatus.CALL_STT_LOG_NO_MEANINGFUL_CONTENT);
            }

            summaryText = geminiService.summarizeCallScript(fullConversation);
            log.info("CallSession (ID: {}) ìš”ì•½ ìƒì„± ì™„ë£Œ.", callSessionId);

            session.updateSummaryDetailed(summaryText);
            log.info("summaryGemini: {}", summaryText);
            callSessionRepository.save(session);
            return summaryText;

        } catch (Exception e) {
            log.error("CallSession (ID: {}) ìš”ì•½ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {}", callSessionId, e.getMessage(), e);
            throw new CallSessionSummaryGenerationException(ErrorStatus.SUMMARY_AI_GEMINI_API_ERROR);
        }
    }
```
</details> 


<details>
  <summary><h3>ì¼ë°˜ ì±„íŒ… & ìƒë‹´ë³„ ì±„íŒ…</h3></summary>

```java
// (Call)ChatStreamController.java
@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/call-chat")
@Tag(name = "CallChatStream", description = "ìƒë‹´ë³„ ì±„íŒ… ì§ˆë¬¸ ì „ì†¡ ê´€ë ¨ API")
public class CallChatStreamController {

    private final ChatbotClient chatbotClient;

    private final CallChatLogService callChatLogService;
    private final CallChatSessionService callChatSessionService;
    private final TokenProvider tokenProvider;

    // 08/13 ì¶”ê°€: STT ë¡œê·¸ ì¡°íšŒìš©
    private final CallSttLogService callSttLogService;

    @Operation(
            summary = "ìƒë‹´ë³„ ì±„íŒ… ì§ˆë¬¸ ì „ì†¡ API",
            description ="ìƒë‹´ì›ì´ ì…ë ¥í•œ ë²•ë¥  ì§ˆë¬¸ì„, ë¬¸ë§¥ì„ ìœ ì§€í•˜ê³  ìˆëŠ” ì±—ë´‡ì—ê²Œ ì „ì†¡í•˜ê³  ì‘ë‹µì„ ë°›ì•„ì˜µë‹ˆë‹¤."
    )
    @GetMapping(value = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> streamCallChat(
            @Parameter(description = "ëŒ€í™”ê°€ ê¸°ë¡ë  CallChatSession ID", required = true)
            @RequestParam Long callChatSessionId,

            @Parameter(description = "ì§ˆë¬¸ ë‚´ìš©", required = true)
            @RequestParam String question,

            @Parameter(description = "JWT í† í°", required = true)
            @RequestParam String token
    ) {
        // 1) JWT â†’ userId
        Long userId = tokenProvider.validateAndGetUserId(token);

        // 2) ì„¸ì…˜ ì†Œìœ ê¶Œ ê²€ì¦
        CallChatSession session = callChatSessionService.getSessionById(callChatSessionId);
        if (!session.getUser().getId().equals(userId)) {
            throw new CallChatGeneralException(ErrorStatus.CALLCHAT_SESSION_FORBIDDEN);
        }

        // Scripts êµ¬ì„± (callchatbot ì„œë¹„ìŠ¤ ë¡œì§ ì¬ì‚¬ìš©)
        List<Map<String, String>> contextScripts = List.of(); // ê¸°ë³¸ ë¹ˆ ë¦¬ìŠ¤íŠ¸
        if (session.getCallSession() != null) {
            Long callSessionId = session.getCallSession().getId();
            List<CallSttLog> logs = callSttLogService.getAllBySessionId(callSessionId);

            // (A) ì „ë¶€ ì „ì†¡ (2ë²ˆê³¼ ë™ì¼)
            List<Map<String, String>> scripts = new ArrayList<>(logs.size());
            for (CallSttLog log : logs) {
                scripts.add(Map.of(
                        "speaker", log.getTrack().name(),  // INBOUND / OUTBOUND
                        "text", log.getScript()
                ));
            }

            // (ì˜µì…˜) í˜ì´ë¡œë“œ ìµœì í™”: abuse êµ¬ê°„ Â±2í„´ + ì´ 6000ì ì»·
            // scripts = trimByAbuseWindowAndLength(logs, 2, 6000);

            contextScripts = scripts;
        }

        StringBuilder jsonBuffer = new StringBuilder();

        // 3) FastAPI í˜¸ì¶œ
        return chatbotClient.sendChatRequest(
                        "/ai/callchat/stream",
                        Map.of(
                                "session_id", callChatSessionId,   // ë°±ì—”ë“œ ë©”ëª¨ë¦¬ í‚¤ë¡œ ì“°ê³  ì‹¶ìœ¼ë©´ ì´ ê°’ í™œìš©
                                "question", question,
                                "context_scripts", contextScripts
                        )
                )
                .map(raw -> {                                            // data: ì¡°ê±´ë¶€ ì œê±°
                    String s = raw == null ? "" : raw.trim();
                    if (s.startsWith("data:")) s = s.substring(5).trim();
                    return s;
                })
                .filter(s -> !s.isEmpty())
                .doOnNext(chunk -> {
                    if ("[END]".equals(chunk)) return;                  // ê·¸ëŒ€ë¡œ í”„ë¡ íŠ¸ë¡œ
                    if (chunk.startsWith("[ERROR]")) {                  // ì—ëŸ¬ ë¡œê·¸
                        log.error("SSE ERROR from FastAPI: {}", chunk);
                        return;
                    }
                    if (chunk.startsWith("[JSON]")) {                   // ë²„í¼ ì´ˆê¸°í™” í›„ ì €ì¥
                        jsonBuffer.setLength(0);
                        jsonBuffer.append(chunk.substring("[JSON]".length()).trim());
                    }
                })
                .doOnError(e -> log.error("SSE proxy error", e))        // ì—ëŸ¬ í•¸ë“¤ë§
                .doOnComplete(() -> {
                    try {
                        if (jsonBuffer.length() == 0) return;           // JSON ì—†ìœ¼ë©´ ìŠ¤í‚µ
                        ObjectMapper mapper = new ObjectMapper();
                        JsonNode node = mapper.readTree(jsonBuffer.toString());

                        String answer = node.has("answer") ? node.get("answer").asText() : "";
                        String sourcePages = (node.has("sourcePages") && !node.get("sourcePages").isNull())
                                ? node.get("sourcePages").toString()
                                : "[]";

                        callChatLogService.saveCallChatLog(
                                callChatSessionId,
                                question,
                                answer,
                                sourcePages
                        );
                    } catch (Exception e) {
                        log.error("âŒ ìƒë‹´ë³„ ì±„íŒ… ì €ì¥ ì‹¤íŒ¨", e);
                        throw new CallChatGeneralException(ErrorStatus.CALLCHAT_LOG_SAVE_FAILED);
                    }
                })
                .delayElements(Duration.ofMillis(5));
    }
}
```

```python
# rag_chatbotstream.py (í•´ë‹¹ ì½”ë“œëŠ” ì¼ë°˜ ì±„íŒ…ì½”ë“œ. ìƒë‹´ë³„ ì±„íŒ…ì½”ë“œë„ ì´ì™€ ìœ ì‚¬í•¨)
# Pineconeì—ì„œ queryì™€ ìœ ì‚¬ ë¬¸ë‹¨ ê²€ìƒ‰ í›„ contextì™€ sourcePages ë°˜í™˜
def retrieve_context(query: str, top_k: int = 2):
    embedding = client.embeddings.create(
        input=[query],
        model="text-embedding-3-small"
    ).data[0].embedding

    results = index.query(vector=embedding, top_k=top_k, include_metadata=True)

    context_blocks = []
    source_pages = []
    for match in results.get("matches", []):
        meta = match.get("metadata", {}) or {}
        typ = (meta.get("ìœ í˜•") or "").strip() or "ì—†ìŒ"
        law = (meta.get("ê´€ë ¨ ë²•ë¥ ") or "").strip() or "ì—†ìŒ"

        context_blocks.append(
            f"ğŸ“Œ **ìœ í˜•:** {typ}\n"
            f"ğŸ“– ë³¸ë¬¸: {meta.get('ë³¸ë¬¸', '')}\n"
            f"âš– **ê´€ë ¨ ë²•ë¥ **: {law}\n"
            f"ğŸ“ ìš”ì•½: {meta.get('ìš”ì•½', '')}\n"
        )
        # ìµœì¢… JSONì—ì„œëŠ” 'ê´€ë ¨ë²•ë¥ '(ë„ì–´ì“°ê¸° ì—†ìŒ)
        # 'ì—†ìŒ'ì€ ì œì™¸í•´ sourcePages ì •í•©ì„± ë³´ì¥
        if law and law != "ì—†ìŒ":
            law_norm = _normalize_law_name(law)  # ì¶”ê°€: ê´„í˜¸Â·ì£¼ì„ ì œê±°
            source_pages.append({"ìœ í˜•": typ, "ê´€ë ¨ë²•ë¥ ": law_norm})

    return "\n---\n".join(context_blocks), source_pages

# 6. GPT ìŠ¤íŠ¸ë¦¬ë° + JSON ì‘ë‹µ (í‚¤ì›Œë“œ ê¸°ë°˜ ë²•ë¥ ì„ sourcePages 1ì°¨ ë°˜ì˜)
@router.post("/stream")
async def stream_chat(query: Query):
    # 0) ì¼ìƒ ëŒ€í™”ë©´ ì¦‰ì‹œ SSEë¡œ ì‘ë‹µí•˜ê³  ì¢…ë£Œ (ëª¨ë¸/RAG í˜¸ì¶œ ì—†ì´)
    if is_smalltalk(query.question):
        async def smalltalk_events():
            payload = {"answer": smalltalk_reply(query.question), "sourcePages": []}
            yield f"data: [JSON]{json.dumps(payload, ensure_ascii=False)}\n\n"
            yield "data: [END]\n\n"
        return EventSourceResponse(smalltalk_events())
    
    # RAG
    context, source_pages_rag = retrieve_context(query.question)
    
   
# ê´€ë ¨ë²•ë¥  ì¤‘ë³µ ì œê±°í•´ì£¼ëŠ” í•¨ìˆ˜  
# ë²•ë¥ ëª… ì •ê·œí™” (ê´„í˜¸Â·ì£¼ì„ ì œê±°)
def _normalize_law_name(law: str) -> str:
    """
    ë²•ë¥ ëª… + ì¡°ë¬¸ë²ˆí˜¸ë§Œ ë‚¨ê¸°ê³  ê´„í˜¸/ì£¼ì„ì€ ì œê±°
    ì˜ˆ: 'ë¯¼ì›ì²˜ë¦¬ë²• ì œ23ì¡° (3íšŒ ì´ìƒ ë°˜ë³µ ì‹œ ì¢…ê²°)' â†’ 'ë¯¼ì›ì²˜ë¦¬ë²• ì œ23ì¡°'
    """
    if not law:
        return ""
    return re.sub(r"\s*\(.*?\)", "", law).strip()

# ìœ í˜•, ë²•ë¥  ì¤‘ë³µ í•­ëª©ì„ ì œê±° 
# sourcePages í›„ì²˜ë¦¬ (ì¤‘ë³µ ì œê±°, ìµœëŒ€ 3ê°œ ìœ ì§€)
def _post_filter_sources(sources, limit=3):
    """
    - ë²•ë¥ ëª…ë§Œ ê¸°ì¤€ìœ¼ë¡œ ì¤‘ë³µ ì œê±° (ìœ í˜•ì´ ë‹¬ë¼ë„ ê°™ì€ ë²•ë¥ ì´ë©´ 1ê°œë§Œ)
    - ì§€ì¹¨/ê°€ì´ë“œ ë“± ë¹„ë²•ë¥ ë„ í—ˆìš© (ìš”êµ¬ì‚¬í•­ ë°˜ì˜)
    - ê´„í˜¸ ì„¤ëª… ì œê±°(normalize) + ; , ë¡œ ë¬¶ì¸ í•­ëª© ë¶„í• 
    - ìµœëŒ€ limitê°œ ìœ ì§€
    """
    out = []
    seen_laws = set()

    for e in sources or []:
        typ = (e.get("ìœ í˜•") or "").strip()
        raw_law = (e.get("ê´€ë ¨ë²•ë¥ ") or "").strip()
        if not typ or not raw_law or raw_law == "ì—†ìŒ":
            continue

        # ì—¬ëŸ¬ ê°œ í•œ ì¤„ì¼ ìˆ˜ ìˆìœ¼ë‹ˆ ë¶„í• 
        for lw in [x.strip() for x in re.split(r"[;,]", raw_law) if x.strip()]:
            norm = _normalize_law_name(lw)  # ê´„í˜¸/ì£¼ì„ ì œê±°
            key = norm.lower()
            if not norm:
                continue
            # ë²•ë¥  ê¸°ì¤€ìœ¼ë¡œ dedup (ìœ í˜•ì€ ë‹¬ë¼ë„ ê°™ì€ ë²•ë¥ ì´ë©´ skip)
            if key in seen_laws:
                continue
            seen_laws.add(key)
            out.append({"ìœ í˜•": typ, "ê´€ë ¨ë²•ë¥ ": norm})
            if len(out) >= limit:
                return out

    return out
```
</details> 
